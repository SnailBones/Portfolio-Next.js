# Prism Escape

In September 2019, I started work at _Electric Playhouse_, where I built games merging the digital and physical worlds. _Prism Escape_, also known as _Space Runner_ was my first game for a three-walled pod and the first game at Electric Playhouse to display a virtual 3D environment.

Through my work at Electric Playhouse, I sought to create games for everyone, not just traditional gamers. Thus, accessibility was crucial. Smartphone games and classic video games are the most popular and broadly recognized games, so I turned to their design language to build games that could be broadly recognized and give all players familiar cues to navigate a novel interface. In the case of _Prism Escape_, I merged the popular endless runner and racing genres.

In endless runner and classinc racing games, the player guides a character around obstacels as far or fast as they can, using a joystick, arrow keys, or a touchscreen. The data provided by sensors in an Electric Playhouse pod is detailed, but it lacks the discrete quality of traditional inputs, with no simple way to tell a player's avatar to move left or right. Instead, we have a depth mask, a virtual shadow created from sensor data representing the player's body. Effectively, it's a 1-bit image texture, or an array of positions where each one is marked as either 1—something here—or 0—empty space.

Thus, I conceived of using the player's depth mask as their "avatar"—considering a collision as occurring when the player's shadow sufficiently overlaps with a game object. Unfortunately, individually counting the pixels is far too slow in practice.

Game logic runs in JavaScript on the CPU, while depth is manipulated in GLSL shaders—harnessing the extreme parallelization of GPUs to perform intense image processing operations that would bring the CPU to a halt. Unfortunately, moving data from the GPU to the CPU is a slow operation and critical bottleneck. Previous games at Electric Playhouse featured circular "colliders," implmented through a Euclidean distance transform and sampling at a single escape. For _Prism Escape_, I needed rectangular colliders of different sizes. What's more, I soon found that evenly applied penalties felt unfair—direct hits needed to have a bigger impact than grazing an obstacle. I needed a collision-detection solution that could accurately judge the degree of collision without sacrificing the game's performance.
